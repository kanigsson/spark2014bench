(set-info :smt-lib-version 2.6)
(set-logic AUFBVFPDTNIRA)
(set-info :source |
Generated by: AdaCore
Generated on: 2020-03-06
Generator: SPARK
Application: Program verification for Ada
Target solver: CVC4
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort string 0)

(declare-datatypes ((tuple0 0))
(((Tuple0))))
(declare-sort us_private 0)

(declare-fun private__bool_eq (us_private us_private) Bool)

(declare-const us_null_ext__ us_private)

(declare-sort us_type_of_heap 0)

(declare-datatypes ((us_type_of_heap__ref 0))
(((us_type_of_heap__refqtmk (us_type_of_heap__content us_type_of_heap)))))
(declare-sort us_image 0)

(declare-datatypes ((int__ref 0))
(((int__refqtmk (int__content Int)))))
(declare-datatypes ((bool__ref 0))
(((bool__refqtmk (bool__content Bool)))))
(declare-datatypes ((us_fixed__ref 0))
(((us_fixed__refqtmk (us_fixed__content Int)))))
(declare-datatypes ((real__ref 0))
(((real__refqtmk (real__content Real)))))
(declare-datatypes ((us_private__ref 0))
(((us_private__refqtmk (us_private__content us_private)))))
(define-fun int__ref___projection ((a int__ref)) Int (int__content a))

(define-fun us_fixed__ref___projection ((a us_fixed__ref)) Int (us_fixed__content
                                                               a))

(define-fun bool__ref___projection ((a bool__ref)) Bool (bool__content a))

(define-fun real__ref___projection ((a real__ref)) Real (real__content a))

(define-fun us_private__ref___projection ((a us_private__ref)) us_private 
  (us_private__content a))

(declare-sort resource 0)

(declare-fun resourceqtint (resource) Int)

;; resource'axiom
  (assert
  (forall ((i resource))
  (and (<= 0 (resourceqtint i)) (<= (resourceqtint i) 1000))))

(define-fun in_range ((x Int)) Bool (and (<= 0 x) (<= x 1000)))

(declare-fun attr__ATTRIBUTE_IMAGE (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE (us_image) Int)

(declare-fun user_eq (resource resource) Bool)

(declare-const dummy resource)

(declare-datatypes ((resource__ref 0))
(((resource__refqtmk (resource__content resource)))))
(define-fun resource__ref_resource__content__projection ((a resource__ref)) resource 
  (resource__content a))

(define-fun to_rep ((x resource)) Int (resourceqtint x))

(declare-fun of_rep (Int) resource)

;; inversion_axiom
  (assert
  (forall ((x resource))
  (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; range_axiom
  (assert
  (forall ((x resource)) (! (in_range (to_rep x)) :pattern ((to_rep x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                           (of_rep x))) )))

(declare-datatypes ((map__ref 0))
(((map__refqtmk (map__content (Array Int resource))))))
(declare-fun slide ((Array Int resource) Int Int) (Array Int resource))

;; slide_eq
  (assert
  (forall ((a (Array Int resource)))
  (forall ((first Int))
  (! (= (slide a first first) a) :pattern ((slide a first first)) ))))

;; slide_def
  (assert
  (forall ((a (Array Int resource)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (select (slide a old_first new_first) i) (select a (- i (- new_first old_first)))) :pattern ((select 
  (slide a old_first new_first) i)) ))))))

(define-fun bool_eq ((a (Array Int resource)) (a__first Int) (a__last Int)
  (b (Array Int resource)) (b__first Int)
  (b__last Int)) Bool (ite (and
                           (ite (<= a__first a__last)
                           (and (<= b__first b__last)
                           (= (- a__last a__first) (- b__last b__first)))
                           (< b__last b__first))
                           (forall ((temp___idx_154 Int))
                           (=>
                           (and (<= a__first temp___idx_154)
                           (<= temp___idx_154 a__last))
                           (= (to_rep (select a temp___idx_154)) (to_rep
                                                                 (select b (+ (- b__first a__first) temp___idx_154)))))))
                      true false))

;; bool_eq_rev
  (assert
  (forall ((a (Array Int resource)) (b (Array Int resource)))
  (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
  (=> (= (bool_eq b b__first b__last a a__first a__last) true)
  (and
  (ite (<= a__first a__last)
  (and (<= b__first b__last) (= (- a__last a__first) (- b__last b__first)))
  (< b__last b__first))
  (forall ((temp___idx_154 Int))
  (=> (and (<= a__first temp___idx_154) (<= temp___idx_154 a__last))
  (= (to_rep (select a temp___idx_154)) (to_rep
                                        (select b (+ (- b__first a__first) temp___idx_154)))))))))))

(declare-fun sum ((Array Int resource) Int) Int)

(declare-fun sum__function_guard (Int (Array Int resource) Int) Bool)

(declare-sort natural 0)

(declare-fun naturalqtint (natural) Int)

;; natural'axiom
  (assert
  (forall ((i natural))
  (and (<= 0 (naturalqtint i)) (<= (naturalqtint i) 2147483647))))

(define-fun in_range1 ((x Int)) Bool (and (<= 0 x) (<= x 2147483647)))

(declare-fun attr__ATTRIBUTE_IMAGE1 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check1 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE1 (us_image) Int)

(declare-fun user_eq1 (natural natural) Bool)

(declare-const dummy1 natural)

(declare-datatypes ((natural__ref 0))
(((natural__refqtmk (natural__content natural)))))
(define-fun natural__ref_natural__content__projection ((a natural__ref)) natural 
  (natural__content a))

(define-fun dynamic_invariant ((temp___expr_39 Int) (temp___is_init_35 Bool)
  (temp___skip_constant_36 Bool) (temp___do_toplevel_37 Bool)
  (temp___do_typ_inv_38 Bool)) Bool (=>
                                    (or (= temp___is_init_35 true)
                                    (<= 0 2147483647)) (in_range1
                                    temp___expr_39)))

(declare-sort num 0)

(declare-fun numqtint (num) Int)

;; num'axiom
  (assert (forall ((i num)) (and (<= 0 (numqtint i)) (<= (numqtint i) 6))))

(define-fun in_range2 ((x Int)) Bool (and (<= 0 x) (<= x 6)))

(declare-fun attr__ATTRIBUTE_IMAGE2 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check2 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE2 (us_image) Int)

(declare-fun user_eq2 (num num) Bool)

(declare-const dummy2 num)

(declare-datatypes ((num__ref 0))
(((num__refqtmk (num__content num)))))
(define-fun num__ref_num__content__projection ((a num__ref)) num (num__content
                                                                 a))

(define-fun dynamic_invariant1 ((temp___expr_167 Int)
  (temp___is_init_163 Bool) (temp___skip_constant_164 Bool)
  (temp___do_toplevel_165 Bool)
  (temp___do_typ_inv_166 Bool)) Bool (=>
                                     (or (= temp___is_init_163 true)
                                     (<= 0 6)) (in_range2 temp___expr_167)))

;; sum__def_axiom
  (assert
  (forall ((d (Array Int resource)))
  (forall ((to__ Int))
  (! (=>
     (and (dynamic_invariant1 to__ true true true true) (sum__function_guard
     (sum d to__) d to__))
     (and
     (forall ((d1 (Array Int resource)) (to__1 Int)) (sum__function_guard
     (sum d1 (- to__1 1)) d1 (- to__1 1)))
     (= (sum d to__) (ite (= to__ 0) 0
                     (+ (to_rep (select d to__)) (sum d (- to__ 1))))))) :pattern (
  (sum d to__)) ))))

(declare-const attr__ATTRIBUTE_ADDRESS Int)

(declare-const attr__ATTRIBUTE_ADDRESS1 Int)

(define-fun dynamic_invariant2 ((temp___expr_160 Int)
  (temp___is_init_156 Bool) (temp___skip_constant_157 Bool)
  (temp___do_toplevel_158 Bool)
  (temp___do_typ_inv_159 Bool)) Bool (=>
                                     (or (= temp___is_init_156 true)
                                     (<= 0 1000)) (in_range temp___expr_160)))

;; sum__post_axiom
  (assert
  (forall ((d (Array Int resource)))
  (forall ((to__ Int))
  (! (=> (dynamic_invariant1 to__ true true true true)
     (let ((result (sum d to__)))
     (=> (sum__function_guard result d to__) (dynamic_invariant result true
     false true true)))) :pattern ((sum d to__)) ))))

(assert
;; defqtvc
 ;; File "resources.ads", line 14, characters 0-0
  (not
  (forall ((d (Array Int resource)) (j Int) (o resource)
  (d1 (Array Int resource)) (j1 Int) (o1 resource) (d2 (Array Int resource))
  (j2 Int) (o2 resource) (d3 (Array Int resource)) (j3 Int) (o3 resource)
  (d4 (Array Int resource)) (j4 Int) (o4 resource) (d5 (Array Int resource))
  (j5 Int) (o5 resource) (d6 (Array Int resource)))
  (=> (= j 1)
  (=> (= (to_rep o) j)
  (=> (= d1 (store d j o))
  (=> (= j1 2)
  (=> (= (to_rep o1) j1)
  (=> (= d2 (store d1 j1 o1))
  (=> (= j2 3)
  (=> (= (to_rep o2) j2)
  (=> (= d3 (store d2 j2 o2))
  (=> (= j3 4)
  (=> (= (to_rep o3) j3)
  (=> (= d4 (store d3 j3 o3))
  (=> (= j4 5)
  (=> (= (to_rep o4) j4)
  (=> (= d5 (store d4 j4 o4))
  (=> (= j5 6)
  (=> (= (to_rep o5) j5)
  (=> (= d6 (store d5 j5 o5))
  (=>
  (forall ((d7 (Array Int resource))) (sum__function_guard (sum d7 6) d7 6))
  (< (sum d6 6) 42)))))))))))))))))))))))
(check-sat)
(exit)
